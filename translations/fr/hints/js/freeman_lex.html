<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        Je n'ai aucune id√©e de la mani√®re de commencer √† r√©soudre cette mission.
    </div>
    <div class="answer">
        <p>
            Attrapez une id√©e üí°! Retirez un √©l√©ment de la s√©quence. Puis jusqu'√† la fin de la s√©quence, √©clater des √©l√©ments, comparer chacun avec le tout premier √©clat√© et calculer (et garder) le dernier indice de la partie commune. Retournez une tranche du premier √©l√©ment jusqu'√† l'indice final. 
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ok, par quoi dois-je commencer?
    </div>
    <div class="answer">
        <p>
            Retirez le dernier √©l√©ment de la s√©quence et calculez sa longueur. C'est votre indice de d√©part de la partie commune. Pour un mot, il s'agit du m√™me mot entier.
        </p>
        <pre class="brush: javascript">
let res = arr.pop(), l = res.length;
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Que faire ensuite?
    </div>
    <div class="answer">
        <p>
            Utilisez la boucle <b class="code">while</b> pour <b class="code">arr</b> et extrayez-en des √©l√©ments.
        </p>
        <pre class="brush: javascript">
while (arr.length) {
    let sec = arr.pop(), i = 0;
    ...
}
        </pre>
        <p>
            Vous devez √©galement d√©clarer une nouvelle variable <b class="code">i</b> pour chaque nouveau mot <b class="code">sec</b> afin de d√©terminer ult√©rieurement le dernier indice commun entre ces deux mots <b class="code">res</b> et <b class="code">sec</b>. 
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        J'ai encore besoin d'un indice.
    </div>
    <div class="answer">
        <p>
            Vous devez incr√©menter ce <b class="code">i</b> jusqu'√† ce qu'il soit plus petit que le minimum de la valeur actuelle de l'index maximum <b class="code">l</b> et de la longueur de l'√©l√©ment <b class="code">sec</b> et jusqu'√† ce que les caract√®res √† cet index dans les deux √©l√©ments (<b class="code">res, sec</b>) soient les m√™mes. √âcrivons-le.
        </p>
        <pre class="brush: javascript">
while (i < Math.min(l, sec.length) && res[i] === sec[i]) i++;
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Comment terminer le code?
    </div>
    <div class="answer">
        <p>
            C'est presque termin√©. Vous devez maintenant mettre √† jour l'indice maximal stock√© de la partie commune avec une nouvelle valeur de <b class="code">i</b>. 
        </p>
        <pre class="brush: javascript">
l = i
        </pre>
        <p>
            Ici, vous pouvez proc√©der √† une v√©rification imm√©diate. Si <b class="code">l == 0</b>, cela signifie qu'il n'y a plus de partie commune et vous pouvez renvoyer une cha√Æne vide sans autre forme de proc√®s.
        </p>
        <pre class="brush: javascript">
if (!(l = i)) return "";
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Alors, √† quoi devrait ressembler ma solution finale?
    </div>
    <div class="answer">
        <p>
            Il vous suffit de joindre tous les indices pr√©c√©dents, de renvoyer une tranche du premier √©l√©ment jusqu'√† l'indice commun final et d'envelopper votre code dans une expression de fonction. Il est fortement recommand√© d'utiliser des indices de type pour les donn√©es d'entr√©e et de sortie.
        </p>
        <p>Voici la solution compl√®te:</p>
        <div class="spoiler">
        <pre class="brush: javascript">
function longestPrefix(arr: string[]): string {

    let res = arr.pop(), l = res.length;
    while (arr.length) {
        let sec = arr.pop(), i = 0;
        while (i < Math.min(l, sec.length) && res[i] === sec[i]) i++;
        if (!(l = i)) return "";
    }
    return res.slice(0, l);
}
        </pre>
        </div>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Montrez-moi d'autres solutions!<br />
        parce que je veux √™tre un vrai ü•á Javascript Hero!
    </div>
    <div class="answer">
        <p>Bien s√ªr, prenez-le!</p>
        <p>
            En utilisant la fonction <b class="code">reduce</b> pour comparer chaque mot avec la base et ne garder que la partie commune comme mot de base.
        </p>
        <div class="spoiler">
        <pre class="brush: javascript">
function longestPrefix(arr: string[]): string {

    if (!arr.length) return "";
    return arr.reduce((prev, next) => {
        let i = 0;
        while (i < prev.length && i < next.length && prev[i] === next[i]) i++;
        return prev.substring(0, i);
    });
}
        </pre>
        </div>
        <p>Cliquez sur <b>Best Solutions</b> dans le menu mission et d√©couvrez de nombreuses autres solutions int√©ressantes!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Merci beaucoup! Je comprends mieux maintenant! Tout fonctionne bien!
    </div>
    <div class="answer">
        Heureux de l'apprendre üëç!
    </div>
</div>
</body>