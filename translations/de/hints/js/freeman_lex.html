<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        Ich habe keine Ahnung, wie ich mit der Lösung dieser Aufgabe beginnen soll.
    </div>
    <div class="answer">
        <p>
            Fangen Sie eine Idee 💡! Ziehen Sie ein Element aus der Sequenz. Dann holen Sie bis zum Ende der Sequenz Elemente heraus, vergleichen jedes mit dem allerersten herausgeholten Element und berechnen (und behalten) den letzten Index des gemeinsamen Teils. Geben Sie einen Ausschnitt des ersten Elements bis zum letzten Index zurück. 
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ok, womit soll ich beginnen?
    </div>
    <div class="answer">
        <p>
            Nehmen Sie das letzte Element aus der Sequenz und berechnen Sie seine Länge. Das ist Ihr Startindex für den gemeinsamen Teil. Bei einem Wort handelt es sich um das gleiche ganze Wort.
        </p>
        <pre class="brush: javascript">
let res = arr.pop(), l = res.length;
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Was ist als nächstes zu tun?
    </div>
    <div class="answer">
        <p>
            Verwenden Sie die Schleife <b class="code">while</b> für <b class="code">arr</b> und holen Sie Elemente daraus hervor.
        </p>
        <pre class="brush: javascript">
while (arr.length) {
    let sec = arr.pop(), i = 0;
    ...
}
        </pre>
        <p>
            Sie müssen auch eine neue Variable <b class="code">i</b> für jedes neue <b class="code">sec</b> deklarieren, um später den letzten gemeinsamen Index zwischen diesen beiden Wörtern <b class="code">res</b> und <b class="code">sec</b> herauszufinden. 
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ich brauche noch einen Hinweis.
    </div>
    <div class="answer">
        <p>
            Sie müssen diesen <b class="code">i</b> so lange inkrementieren, bis er kleiner ist als das Minimum aus dem aktuellen Wert des maximalen Index <b class="code">l</b> und der Länge des Elements <b class="code">sec</b> und bis die Zeichen an diesem Index bei beiden Elementen (<b class="code">res, sec</b>) gleich sind. Lassen Sie uns das schreiben.
        </p>
        <pre class="brush: javascript">
while (i < Math.min(l, sec.length) && res[i] === sec[i]) i++;
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Wie wird der Code fertiggestellt?
    </div>
    <div class="answer">
        <p>
            Das ist fast das Ende. Jetzt müssen Sie Ihren gespeicherten Maximalindex des gemeinsamen Teils mit einem neuen Wert von <b class="code">i</b> aktualisieren. 
        </p>
        <pre class="brush: javascript">
l = i
        </pre>
        <p>
            Hier können Sie sofort eine Überprüfung vornehmen. Falls <b class="code">l == 0</b>, bedeutet dies, dass kein gemeinsamer Teil mehr vorhanden ist und Sie können eine leere Zeichenkette zurückgeben, ohne weiter zu ploppen.
        </p>
        <pre class="brush: javascript">
if (!(l = i)) return "";
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Wie sollte also meine endgültige Lösung aussehen?
    </div>
    <div class="answer">
        <p>
            Sie müssen nur alle vorherigen Hinweise zusammenführen, einen Ausschnitt des ersten Elements bis zum letzten gemeinsamen Index zurückgeben und Ihren Code in einen Funktionsausdruck verpacken. Die Verwendung von Typ-Hinweisen für Eingabe- und Ausgabedaten wird dringend empfohlen.
        </p>
        <p>Hier ist die gesamte Lösung:</p>
        <div class="spoiler">
        <pre class="brush: javascript">
function longestPrefix(arr: string[]): string {

    let res = arr.pop(), l = res.length;
    while (arr.length) {
        let sec = arr.pop(), i = 0;
        while (i < Math.min(l, sec.length) && res[i] === sec[i]) i++;
        if (!(l = i)) return "";
    }
    return res.slice(0, l);
}
        </pre>
        </div>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Zeigen Sie mir mehr Lösungen!<br />
        denn ich möchte ein echter 🥇 Javascript-Held sein!
    </div>
    <div class="answer">
        <p>Klar, schnappen Sie es sich!</p>
        <p>
            Verwenden Sie die Funktion <b class="code">reduce</b>, um jedes Wort mit der Basis zu vergleichen und nur den gemeinsamen Teil als Basiswort zu behalten.
        </p>
        <div class="spoiler">
        <pre class="brush: javascript">
function longestPrefix(arr: string[]): string {

    if (!arr.length) return "";
    return arr.reduce((prev, next) => {
        let i = 0;
        while (i < prev.length && i < next.length && prev[i] === next[i]) i++;
        return prev.substring(0, i);
    });
}
        </pre>
        </div>
        <p>Klicken Sie im Missionsmenü auf <b>Best Solutions</b> und sehen Sie sich viele andere interessante Lösungen an!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Vielen Dank! Ich weiß und verstehe jetzt mehr! Alles funktioniert bestens!
    </div>
    <div class="answer">
        Freut mich zu hören 👍!
    </div>
</div>
</body>